#include "ex1_q1.h"


char maskNewPolygon = 2;
char maskEndOfInput = 1;
char maskPolygonType= 15;
LNode *HEAD=NULL, *TAIL = NULL;


int main()
{
	Polygon newPolygon;
	int numOfVertices, i, j, outputExecute, performsOutput;
	unsigned long long command, temp, num1, num2;

	while(1){
	
		scanf("%llx", &command);
		//type of polygon
		numOfVertices = extractpolygonType(command);
		//new polygon to add to the list
		if (command&maskNewPolygon) {
			scanf("%llx", &num1); //Description of vertices
			scanf("%llx", &num2); //Description of vertices
			Point* arr = (Point*)malloc(numOfVertices * sizeof(Point));  //!!!!!!!!free arr!!!!!!!!
			for (i = 0; i < 4; i++) {      //First 4 vertices
				temp = num1;
				temp = temp >> (16 * i);
				arr[i].x = (char)(temp & 255); //255=1111111
				temp = num1 >> (16 * i);
				temp = temp >> 8;
				arr[i].y = (char)(temp & 255); //15=1111
			}

			if (numOfVertices == HEXAGON) {
				for (j = 0; j < 2; j++) {      //Last 2 vertices
					temp = num2;
					temp = temp >> (16 * j);
					arr[j + i].x = (char)(temp & 255); //15=11111111
					temp = num2 >> (16 * j);
					temp = temp >> 8;
					arr[j + i].y = (char)(temp & 255);
				}

			}
			if (numOfVertices == HEPTAGON) {
				for (j = 0; j < 3; j++) {      //Last 3 vertices
					temp = num2;
					temp = temp >> (16 * j);
					arr[j + i].x = (char)(temp & 255); //15=11111111
					temp = num2 >> (16 * j);
					temp = temp >> 8;
					arr[j + i].y = (char)(temp & 255);
				}

			}

			if (numOfVertices == OCTAGON) {
				for (j = 0; j < 4; j++) {      //Last 4 vertices
					temp = num2;
					temp = temp >> (16 * j);
					arr[j + i].x = (char)(temp & 255); //15=11111111
					temp = num2 >> (16 * j);
					temp = temp >> 8;
					arr[j + i].y = (char)(temp & 255);
				}
			}

			newPolygon.arr = arr;
			newPolygon.size = numOfVertices;
			add_polygon(&newPolygon);
		}

		//output to execute
		temp = command;
		temp = temp >> 6;
		temp = temp & 15; //15=1111
		outputExecute = (int)temp;

		//performs output 
		temp = command;
		temp = temp >> 10;
		temp = temp & 15; //15=1111
		performsOutput = (int)temp;

		//output Execution 
		if (performsOutput == 0) {
			outputExecution(outputExecute, &newPolygon);
		}
		else {
			outputExecutionSpecific(outputExecute, performsOutput, HEAD);
		}

		//last command in the program
		if ((command&maskEndOfInput)) { break; }
		
	}
		free_list();

}


void newPolygon( int numOfVertices, unsigned long long command) {
	scanf("%llx", &num1); //Description of vertices
	scanf("%llx", &num2); //Description of vertices
	Point* arr = (Point*)malloc(numOfVertices * sizeof(Point));  //!!!!!!!!free arr!!!!!!!!
	for (i = 0; i < 4; i++) {      //First 4 vertices
		temp = num1;
		temp = temp >> (16 * i);
		arr[i].x = (char)(temp & 255); //255=1111111
		temp = num1 >> (16 * i);
		temp = temp >> 8;
		arr[i].y = (char)(temp & 255); //15=1111
	}

	if (numOfVertices == HEXAGON) {
		for (j = 0; j < 2; j++) {      //Last 2 vertices
			temp = num2;
			temp = temp >> (16 * j);
			arr[j + i].x = (char)(temp & 255); //15=11111111
			temp = num2 >> (16 * j);
			temp = temp >> 8;
			arr[j + i].y = (char)(temp & 255);
		}

	}
	if (numOfVertices == HEPTAGON) {
		for (j = 0; j < 3; j++) {      //Last 3 vertices
			temp = num2;
			temp = temp >> (16 * j);
			arr[j + i].x = (char)(temp & 255); //15=11111111
			temp = num2 >> (16 * j);
			temp = temp >> 8;
			arr[j + i].y = (char)(temp & 255);
		}

	}

	if (numOfVertices == OCTAGON) {
		for (j = 0; j < 4; j++) {      //Last 4 vertices
			temp = num2;
			temp = temp >> (16 * j);
			arr[j + i].x = (char)(temp & 255); //15=11111111
			temp = num2 >> (16 * j);
			temp = temp >> 8;
			arr[j + i].y = (char)(temp & 255);
		}
	}

}




int extractpolygonType(long long command){
	
	command = command >> 2;
	command = command & maskPolygonType;
	if (command == HEXAGON) {	return HEXAGON;}
	if (command == HEPTAGON){	return HEPTAGON;}
	if (command == OCTAGON) {	return OCTAGON;}
	return -1;
}

void add_polygon(struct polygon* poly) {
	extern LNode* HEAD;
	extern LNode* TAIL;
	LNode* newPolygon = (LNode*)malloc(sizeof(LNode));
	newPolygon->next = NULL;
	newPolygon->poly = poly;
	if (TAIL){
		TAIL->next = newPolygon;
	}
	else{
		HEAD = newPolygon;
	}

	TAIL = newPolygon;
	/*
	if (head == NULL) {
		head = newPolygon;
		tail = newPolygon;
	}
	else {
		tail->next = newPolygon;
		tail = newPolygon;
	}
	*/
}


float calc_perimeter(struct polygon* poly) {
	int i;
	float perimeter = 0;
	for (i = 0; i < poly->size ; i++) {
		if (i == poly->size-1) {
			perimeter += distanceBetweenTwoPoints(poly->arr[0], poly->arr[i]);	
		}
		else {
			perimeter += distanceBetweenTwoPoints(poly->arr[i], poly->arr[i + 1]);
		}
	}
	return perimeter;
		
}

float calc_diagonals(struct polygon* poly) {
	int i,j;
	float diagonals = 0;
	for (i = 0; i < poly->size - 1; i++) {
		for (j = i+2; j < poly->size; j++)
		if ((i != 0 )|| (j != poly->size-1)){
			diagonals += (distanceBetweenTwoPoints(poly->arr[i], poly->arr[j]));
		}
	}
	return diagonals;
}


float distanceBetweenTwoPoints (Point p1, Point p2) {
	double x, y;
	x = pow(p1.x - p2.x,2);
	y = pow(p1.y - p2.y, 2);
	return (float)sqrt(x + y);
}


float calc_area(struct polygon* poly) {
	int i;
	float area = 0;
	for (i = 0; i < poly->size; i++) {
		if (i != poly->size- 1){
			area += (((poly->arr[i]).x)*((poly->arr[i + 1]).y)) - (((poly->arr[i]).y)*((poly->arr[i + 1]).x));
		}
		else{
			area += (((poly->arr[i]).x)*((poly->arr[0]).y)) - (((poly->arr[i]).y)*((poly->arr[0]).x));
		}
	}
	return fabs((area)*(0.5));
}

void print_polygon(struct polygon* poly) {
	int i;
	if (poly->size == HEXAGON) {
		printf("hexagon ");
	}
	if (poly->size == HEPTAGON) {
		printf("heptagon ");
	}
	if (poly->size == OCTAGON) {
		printf("octagon ");
	}
	for (i = 0; i < poly->size; i++) {
		printf("{%d, %d} ", (int)(poly->arr[i]).x, (int)(poly->arr[i]).y);
	}
	printf("\n");
	return;
}

void print_perimeter(struct polygon* poly) {
	printf("perimeter =%.1f \n", calc_perimeter(poly));
}

void print_diagonals(struct polygon* poly) {
	printf("diagonals = =%.1f \n", calc_diagonals(poly));
}

void print_area(struct polygon* poly){
	printf("area = =%.1f \n", calc_area(poly));
}


void outputExecution(int outputExecute, struct polygon* poly) {
	if (outputExecute & 1) {
		print_polygon(poly);
	}
	if (outputExecute & 2) {
		print_perimeter(poly);
	}
	if (outputExecute & 4) {
		print_area(poly);
	}
	if (outputExecute & 8) {
		print_diagonals(poly);
	}
}

void outputExecutionSpecific(int outputExecute, int performsOutput, LNode* head) {
	LNode* temp = head;
	while (temp) {
		if (temp->poly->size == performsOutput) {
			outputExecution(outputExecute, temp);
			temp = temp->next;
		}
	
		if (performsOutput == 15) {
			outputExecution(outputExecute, temp);
			temp = temp->next;
		}
	}
}



void free_list()

{
	extern struct Node* HEAD;
	extern struct Node* TAIL;

	struct Node* curr = HEAD;
	struct Node* next;

	while (curr)
	{
		free(curr->poly->arr);
		free(curr->poly);
		next = curr->next;
		free(curr);
		curr = next;

	}
}
